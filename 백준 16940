#include <iostream>
#include <vector>
#include <queue>
using namespace std;

bool bfs(int start, vector<vector<int>>& line, vector<bool>& visit, vector<int>& input)
{
    queue<int> node;
    node.push(start);
    visit[start] = true;

    int idx = start; // 시작 인덱스

    while (!node.empty())
    {
        int pos = node.front();
        node.pop();

        int cnt = 0;
        for (int i = 0; i < line[pos].size(); i++) // 현 노드의 자식 노드들 만큼 반복
        {
            int next = line[pos][i];
            if (!visit[next])
                cnt++; // 미방문한 자식노드의 수
        }

        for (int i = 0; i < cnt; i++)
        {
            int cur = input[idx + i]; // 현 인덱스에서 미방문 자식 노드수만큼
            bool b = false;

            for (int j = 0; j < line[pos].size(); j++) // 실제 자식 노드의 수
            {
                int next = line[pos][j];
                if (next == cur && !visit[next]) // 위 두 조건을 비교
                {
                    b = true;
                    break;
                }
            }

            if (b == false) // 전부 일치하지 않으면 false
                return false;
        }

        for (int i = 0; i < cnt; i++) // 자식노드들의 방문 처리
        {
            int cur = input[idx++];
            visit[cur] = true;
            node.push(cur);
        }
    }

    return true;
}

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int N;
    cin >> N;

    vector<vector<int>> line(N + 1); // 노드의 간선
    vector<bool> visit(N + 1, false); // 노드 방문 여부

    for (int i = 0; i < N - 1; i++) // 노드 연결 입력
    {
        int u, v;
        cin >> u >> v;
        line[u].push_back(v);
        line[v].push_back(u);
    }

    vector<int> input(N); // 사용자 BFS 방문 순서
    for (int i = 0; i < N; i++)
        cin >> input[i];
    
    if(input[0] != 1) // 조건 1에서 시작노드는 무조건 1
        return 0;

    bool result = bfs(input[0], line, visit, input);

    if (result)
        cout << 1 << '\n';
    else
        cout << 0 << '\n';

    return 0;
}
